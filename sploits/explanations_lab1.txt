#Chuanyang Qiao, 1005736385, chuanyang.qiao@utoronto.ca

1.
The buffer overflow originates from strcpy not performing boundary checks and copying data until a null 
character is met. Using gdb, I identify the memory addresses of the buffer in lab_main and the program 
counter of lab_main. I then fill the buffer with my shellcode, add NOPS, and include its address. 
This action overwrites the stored address of the program counter, causing the shell program to execute 
when lab_main tries to return to the invoking function.

2.
I start by placing my malicious code (shellcode) into the buffer. Then, I fill the remaining buffer space 
up to its limit with arbitrary data (using 'A's as an example) for padding. Past the buffer, there's the 
saved base pointer (8 bytes on x86_64 architectures) that I account for. After this saved base pointer lies 
the function's return address. I overwrite this with the memory address of my shellcode. When executing the 
exploit, I supply this crafted string (shellcode + padding + return address) as an argument to the target 
program. Once overflowed, the program's return address directs to my shellcode, executing it and in turn, 
spawning a shell in this scenario.

3.
For this buffer overflow exploit, I strategically fill a buffer with a "NOP sled" leading directly to the 
primary malicious shellcode. I embed specific sequences intending to activate vulnerabilities and overwrite
vital memory addresses, potentially changing a function's return direction. When I run the target program 
with this crafted buffer, my goal is to divert its execution path towards the malicious code. When successful, 
the target program executes the shellcode, which often aims to provide unauthorized access or enable harmful 
operations.

4.
To exploit this target, recognizing its double-free vulnerability, I begin by studying its memory allocation 
patterns. The target first allocates two buffers via tmalloc, sized at 64 bytes and 108 bytes. It then releases 
both buffers with tfree. After this, a third buffer of 172 bytes is allocated, and the input string I give as 
the first argument is copied into it. Due to an error in logic, the target erroneously frees the second buffer
again, rather than the third. Using this flaw and understanding the specifics of the dynamic memory allocation 
 library, I craft a precise input string to capture control over the target's execution.